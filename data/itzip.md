잇집 itzip

개발자 취준생을 위한 종합 취업 준비 플랫폼으로, 블로그, 학습, 구인 정보 등을 제공하는 웹 서비스.

팀명 : itzip
진행 기간 : 2024.06 ~ 2025.03
멤버 : fe 4, be 5, de 4

기술 스택

- 타입스크립트
- nextjs
- tailwindcss
- jotai - 대부분의 페이지에서 사용자의 토큰을 필요로 하기 때문에 propsdrilling을 방지하고자 상태관리 라이브러리인 jotai를 사용하게 되었습니다.
- zod - formdata의 유효성 검사를 하기 위해 사용하였습니다.
- storybook - 많은 인원과 함께 개발을 해야하는 과정에서 모두가 일관성을 유지하고, 재사용성을 높이고, 효율적인 개발 프로세스를 구축하기 위해 스토리북을 활용하여 공통 컴포넌트를 제작하여 사용하였습니다.

주요 작업

1. 사용자 인증 플로우 구현
2. 사용자 프로필 관리 시스템 구현
3. 토큰 기반 자동 인증 갱신 시스템 구현

4. 사용자 인증 플로우 구현

- 사용자는 이메일, 비밀번호를 입력하여 로그인 할 수 있습니다.
- 회원가입을 위해서는 이메일 인증이 필요합니다.
- formData는 Zod를 활용하여 유효성 검사를 진행합니다.

2. 사용자 프로필 관리 시스템 구현

- 사용자는 프로필 정보를 수정할 수 있습니다.
- 닉네임은 회원가입 진행 시 입력하지 않고 랜덤 문자열을 사용하게 됩니다.
- 닉네임은 프로필 수정을 통해 중복되지 않도록 중복 검사를 진행 후 수정할 수 있습니다.
- 프로필 수정 시 이미지 업로드를 통해 수정할 수 있고 미리보기로 변경 된 이미지를 확인 할 수 있습니다.
- 변경하기를 눌러야만 서버에 이미지가 전달되어 수정이 완료 됩니다.

3. 토큰 기반 자동 인증 갱신 시스템 구현

- interceptor의 헤더 noAuth를 활용하여 각 요청마다 인증이 필요한 경우와 필요하지 않은 경우를 구분합니다.
- 유저가 로그인 시 토큰이 발급되고 토큰(액세스, 리프레쉬)은 쿠키에 저장됩니다.
- 토큰은 useTokenStore 훅에서 jotai store에 저장되고 상태를 관리합니다.
- isRefreshing 플래그를 사용하여 동시에 여러 요청이 토큰 갱신을 시도하는 것을 방지 합니다.
- 토큰 갱신 요청이 완료되면 플래그를 false로 변경하여 다시 요청이 들어왔을 때 토큰 갱신을 시도할 수 있도록 합니다.
- 토큰 갱신 중에 들어오는 요청들은 refreshSubscribers 배열에 저장하여 토큰 갱신 완료 후 요청들을 처리합니다.

3-1. 트러블 슈팅

1. 401 무한 루프 & 토큰 갱신 문제
   문제 상황

- 액세스 토큰이 만료된 뒤 API 요청을 보내면 401이 발생했고, 이를 axios 응답 인터셉터에서 자동으로 리프레시 토큰으로 갱신하도록 구현했는데, 설정이 잘못되어 같은 요청이 계속 재시도 되며 401 무한 루프가 발생했습니다.

원인 분석

- 토큰이 만료된 요청이 인터셉터에서 다시 instance(originalRequest)로 호출 되면서, \_retry 플래그나 isRefreshing 처리 없이 동일한 인터셉터 로직을 계속 타는 구조였습니다.
- 동시에 여러 요청이 401을 받으면, 각 요청이 각자 리프레시 토큰을 사용해 갱신을 시도하는 문제도 발생했습니다.

해결 방법

- 요청 config에 \_retry 플래그를 추가해, 한 번 갱신을 시도한 요청은 다시 갱신 로직을 타지 않도록 막았습니다.
- isRefreshing 플래그와 refreshSubscribers 큐를 두어,
  - 첫번째 401에서만 실제 리프레시 요청을 보내고,
  - 나머지 요청은 리프레시가 끝난 뒤 새 토큰을 받아 다시 시도하는 구조로 변경했습니다.
- 이를 통해 401 무한 루프를 방지하면서도, 동시에 여러 요청이 들어올 때 리프레시 요청은 한번만 보내는 안정적인 토큰 갱신 플로우를 만들었습니다.

2. 쿠키에 저장한 토큰이 안보이는/안 보내지는 문제
   문제 상황

- 로그인 후 토큰을 쿠키에 저장했음에도, 새로고침 이후 일부 환경에서 토큰이 읽히지 않거나 API 요청 시 인증이 되지 않는 문제가 발생했습니다.

원인 분석

- secure, sameSite 옵션을 잘못 설정해,
  - 로컬 개발 환경(http)에서 secure 옵션 때문에 쿠키가 저장되지 않거나
  - sameSite='strict' 설정 때문에 외부 도메인/특정 요청 패턴에서 쿠키가 전송되지 않는 경우가 있었습니다.
  - 또한, 새로고침 시 쿠키 -> 전역 상태(jotai)로의 동기화 시점을 고려하지 않고 구현해, 초기 렌더링 시점에는 토큰이 없는 상태로 요청이 나가는 문제도 발생했습니다.

해결 방법

- 개발/운영 환경에 따라 secure 옵션을 분기 처리하고, sameSite 설정을 재점검했습니다.
- TokenSync 컴포넌트를 만들어, 웹이 처음 렌더링될 때 쿠키에서 토큰을 읽어와 jotai 상태에 동기화하도록 수정했습니다.
- 그결과 새로고침 이후에도 일관되게 토큰이 유지되고, 인증 헤더가 안정적으로 붙은 동작을 확인할 수 있었습니다.

3. 인증이 필요 없는 API에도 토큰이 붙어 에러가 나는 문제
   문제 상황

- 회원가입, 이메일 중복 확인, 인증 코드 전송 등 인증이 필요 없는 API 호출에서도
  Authorization: Bearer ... 헤더가 항상 붙어, 서버에서 예상치 못한 인증 에러가 발생하는 문제가 있었습니다.

원인 분석

- axios 요청 인터셉터에서 모든 요청에 무조건 Authorization 헤더를 추가하고 있었기 때문에, 비로그인 상태에서 호출하는 /user/join, /user/authEmail 등의 API도 잘못된 토큰과 함께 호출되었습니다.

해결 방법

- axios 인스턴스에 noAuth라는 커스텀 헤더를 정의하고,
- noAuth: true가 설정된 요청은 인터셉터에서 Authorization 헤더를 추가하지 않도록 분기처리를 넣었습니다.
  이를 통해 비인증 API 와 인증이 필요한 API를 명확히 분리하고, 회원가입/이메일 인증 플로우가 토큰 상태와 상관없이 안정적으로 동작하도록 만들 수 있었습니다.

마무리
이 프로젝트를 시작했을 때는 인증/인가에 대한 이해가 거의 없었고, 지인들의 도움과 검색에 많이 의존했습니다.

하지만 시행착오를 겪으며 흐름을 하나씩 구현하는 과정에서, 이제는 사용자 인증/인가 플로우를 스스로 설계하고 설명할 수 있을 정도의 경험과 인사이트를 쌓게 되었습니다.

## 프로젝트 인증 구조 요약

이 프로젝트에서는 단순한 세션/쿠키 기반 인증 대신, JWT 기반 토큰 인증을 선택했습니다. 토큰은 쿠키에 저장하되, 실제 인증은 Authorization: Bearer 헤더를 통해 처리하여, 웹/모바일 등 다양한 클라이언트에서 재사용 가능한 Stateless API 구조를 경험해 보고자 했습니다. 이 과정에서 토큰 저장/갱신/무효화, axios 인터셉터, Jotai 전역 상태 관리 등을 직접 설계하며 토큰 인증 방식의 장단점과 보안 트레이드오프를 학습했습니다.

## 왜 굳이 더 불편한 구조를 선택했는지

- 프론트/백 분리 & 확장성을 고려한 선택

  - 세션/쿠키 방식은 브라우저 웹 환경에는 편하지만, 모바일 앱/외부 서비스/다른 클라이언트까지 확장할 때 제약이 많습니다.
  - 반면 Bearer 토큰 방식은 "HTTP 헤더만 맞추면" 어떤 클라이언트에서도 동일하게 사용할 수 있어, API 서버 구조와 잘 맞습니다.

- Stateless 아키텍처 경험을 해보고 싶었습니다.

  - 세션 방식은 서버 측에 상태(세션 저장소)를 두기 때문에, 서버 수평 확장, 로드 밸런싱 시 세션 공유/동기화 이슈가 생깁니다.
  - JWT 기반 인증은 서버가 요청마다 토큰만 검증하면 되기 때문에, 상대적으로 Stateless에 가까운 구조를 설계해 볼 수 있습니다.
  - 이 프로젝트 자체가 새로운 기술에 대한 도전을 추구하기 때문에 실제 서비스 아키텍처에서 많이 사용하는 패턴을 직접 경험해 보려는 의도가 있습니다.

- 인증/인가 로직을 프론트 코드 레벨에서 명확히 제어하고 싶었습니다.
  - 세션/쿠키 기반은 브라우저가 알아서 쿠키를 보내기 때문에 프론트 코드에서 인증이 "보이지 않는" 느낌이 강합니다.
  - 이 프로젝트에서는 axios 인터셉터를 통해 요청마다 어떤 헤더가 붙는지, 토큰이 갱신되면 어떻게 다시 저장되는지를 코드로 직접 다루면서, 토큰 인증 흐름 전체를 이해하고 설계하는 경험을 얻는 것을 목표로 했습니다.

## 이 방식의 장단점

- 장점

  - 클라이언트 확장성
    - 프로그래머스 부트캠프를 통해 react native 과정을 수료하였기 때문에 모바일 앱에 대한 확장 가능성을 고려했습니다.
  - Stateless에 가까운 서버 구조
    - 서버에 세션 상태를 별도로 저장하지 않기 때문에, 수평 확장성과 배포 전략을 유연하게 가져갈 수 있습니다.
  - 명시적인 인증 흐름
    - axios 인터셉터, 토큰 저장/갱신 로직 등 프론트 코드 안에서 인증 과정을 명시적으로 관리할 수 있어, 인증 실패/만료/재발급 등 예외 처리를 세밀하게 설계할 수 있습니다.
  - 보안 설정을 직접 설계
    - 쿠키 옵션(secure, sameSite)과 토큰 만료 시간, 리프레시 토큰 전략 등을 직접 설계하면서 XSS/CSRF에 대한 이해와 대응 방법을 함께 정리할 수 있습니다.

- 단점
  - 구현 복잡도 증가
    - 단순 세션/쿠키 방식과 달리
      1. 토큰 발급/저장(쿠키),
      2. 전역 상태 동기화(jotai),
      3. 요청 인터셉터로 헤더 추가,
      4. 401 응답 시 토큰 재발급 및 재요청 처리
         같은 로직을 모두 직접 구현해야해서 엄청난 시간과 노력이 필요합니다.
    - 토큰 무효화 관리가 어렵다.
      - 세션은 서버에서 지우면 끝이지만, JWT는 이미 발급된 토큰을 강제 만료시키려면 블랙리스트/버전 관리 등 추가 설계가 필요하지만 관리자 패널을 구현하지 않는 것으로 진행이 되었기 때문에 토큰에 짧은 만료 시간을 설정하는 방법으로 타협했습니다.
    - 보안 트레이드오프
      - 토큰을 어디에 저장하느냐(쿠키, 로컬스토리지)에 따라 XSS/CSRF 위험도가 달라지기 때문에, 그에 맞는 방어 전략을 함께 고려해야 하지만 이번 프로젝트에서는 구조 설계에 집중하면서, 모든 공격에 완벽하게 대응하는 수준까지는 도달하지 못했습니다.
    - 단기적으로는 개발 편의성이 떨어진다.
      - 원래의 개발 기간이 단기간으로 끝내자로 시작했지만 토큰 기반 인증 구조를 직접 설계/구현하면서 예상보다 기간이 늘어났고, 개인적으로 구현 난이도가 높게 느껴지는 선택이었습니다.

## 이 프로젝트에서 사용한 토큰 인증 관련 기술

JWT 기반 토큰 인증 구조

- 백엔드에서 발급하는 accessToken / refreshToken을 사용
- 요청 시 Authorization: Bearer <accessToken> 헤더로 인증

쿠기 저장 및 관리 - js-cookie

- accessToken, refreshToken을 브라우저 쿠키에 저장해 새로고침/재접속 시에도 인증이 유지
- secure, sameSite, expires 등의 옵션을 설정해, 토큰 유효 기간과 보안 속성을 조절
  전역 토큰 상태 관리 - jotai
- TokenSync 컴포넌트에서 쿠키 -> Jotai 전역 상태로 토큰을 동기화
- 로그인/리프레시 시에는 jotai 상태와 쿠키를 동시에 갱신해, 앱 전역에서 토큰 상태를 일관되게 사용
  HTTP 통신 & 인터셉터 - axios 커스텀 인스턴스
- axiosInstance에 요청 인터셉터를 걸어
  - noAuth 헤더가 없는 요청에 한해 전역 상태에 저장된 accessToken을 읽어와 Authorization: Bearer <token> 헤더를 자동으로 추가
  - 응답 인터셉터에서
    - 401 응답이 오면 리프레시 토큰으로 /user/refreshToken API를 호출해 토큰을 재발급 받고,
    - 성공 시 새 토큰을 쿠키 + jotai 상태에 저장하고,
    - 대기 중이던 요청들의 헤더를 갱신한 뒤 다시 재시도 하는 로직을 구현

이 경험을 통해 사용자 인증 플로우를 단순 사용자가 아닌 설계자 관점에서 깊이 있게 다뤄 볼 수 있었고,

그 과정에서 제가 선택한 기술과 아키텍처에 담긴 의도를 팀원에게 논리적으로 설명하고 설득하는 커뮤니케이션 능력도 함께 성장시킬 수 있었습니다.

참고

- [인증과 인가의 차이(기본 개념 정리)](https://jake-seo-dev.tistory.com/76)

- [OAuth 2.0 동작 원리 정리](https://kimyc1223.github.io/blog/2023/09/25/TechPost.html)

- [개념 정리](https://velog.io/@leehyunho2001/%EB%A1%9C%EA%B7%B8%EC%9D%B8)

- [JWT 토큰 인증 방식](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-JWTjson-web-token-%EB%9E%80-%F0%9F%92%AF-%EC%A0%95%EB%A6%AC)
